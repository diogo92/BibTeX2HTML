/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;  IGNORE_CASE = true;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  lookahead = 10;}PARSER_BEGIN(BibParser)package bibtex2html.parser;import java.util.Vector;import java.util.Scanner;import java.util.Collections;import java.util.Enumeration;import java.util.Hashtable;import java.util.Stack;
import java.io.InputStream;import bibtex2html.data.*;import bibtex2html.reader.FileReader;import bibtex2html.utils.*;
import bibtex2html.htmlcreator.*;public class BibParser{  public static Hashtable symbtab = new Hashtable();

  public static HTMLWriter HTMLout;

  // Recyclable Structure to set in the intermediate memory
  public static BibData tmp_data;

  // Counter for current amount of types handled
  public static int count_data;

  public static boolean err_data;
    public static Vector < Vector < Object >> tree;  public static Vector < String > keys;

  public static Stack < Object > stack;  public static boolean firstStack = true;  public static int currIndex = 0;

  public static InputStream bibParser = null;

  // Sets the correct type in the data vector
  public static void setTypeData(String type)  {
    if(type.equals("article"))    {
      ArticleData in = new ArticleData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.journal, tmp_data.year, tmp_data.volume, tmp_data.number, tmp_data.pages, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.ArticleList.add(in);
      return;
    }
    if(type.equals("book"))
    {
      BookData in = new BookData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.publisher, tmp_data.year, tmp_data.volume, tmp_data.number, tmp_data.edition, tmp_data.series, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.BookList.add(in);
      return;    }
    if(type.equals("booklet"))
    {
      BookletData in = new BookletData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.howpublished, tmp_data.year, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.BookletList.add(in);
      return;
    }
    if(type.equals("conference"))
    {
      ConferenceData in = new ConferenceData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.number, tmp_data.series, tmp_data.pages, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.ConferenceList.add(in);
      return;    }
    if(type.equals("inbook"))    {
      InbookData in = new InbookData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.chapter, tmp_data.pages, tmp_data.publisher, tmp_data.year, tmp_data.volume, tmp_data.series, tmp_data.type, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.InbookList.add(in);
      return;    }
    if(type.equals("incollection"))
    {
      IncollectionData in = new IncollectionData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.publisher, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.series, tmp_data.type, tmp_data.chapter, tmp_data.pages, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.IncollectionList.add(in);
      return;    }
    if(type.equals("inproceedings"))    {
      InproceedingsData in = new InproceedingsData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.number, tmp_data.series, tmp_data.pages, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.InproceedingsList.add(in);
      return;
    }
    if(type.equals("manual"))    {
      ManualData in = new ManualData(tmp_data.getCitationKey(), tmp_data.title, tmp_data.author, tmp_data.organization, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.year, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.ManualList.add(in);      return;
    }
    if(type.equals("mastersthesis"))
    {
      MastersthesisData in = new MastersthesisData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.school, tmp_data.year, tmp_data.type, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.MastersthesisList.add(in);
      return;    }
    if(type.equals("misc"))
    {
      MiscData in = new MiscData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.howpublished, tmp_data.month, tmp_data.year, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.MiscList.add(in);
      return;    }
    if(type.equals("phdthesis"))
    {
      PhdthesisData in = new PhdthesisData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.school, tmp_data.year, tmp_data.type, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.PhdthesisList.add(in);
      return;    }
    if(type.equals("proceedings"))
    {
      ProceedingsData in = new ProceedingsData(tmp_data.getCitationKey(), tmp_data.title, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.series, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.ProceedingsList.add(in);
      return;    }
    if(type.equals("techreport"))
    {
      TechreportData in = new TechreportData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.institution, tmp_data.year, tmp_data.type, tmp_data.number, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key, tmp_data.crossref);
      // -- DEBUG --System.out.println(in.toString());
      HTMLout.TechreportList.add(in);
      return;    }
    if(type.equals("unpublished"))
    {
      UnpublishedData in = new UnpublishedData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.note, tmp_data.month, tmp_data.year, tmp_data.key, tmp_data.crossref);
      // -- DEBUG -- //System.out.println(in.toString());
      HTMLout.UnpublishedList.add(in);
      return;    }  }

  // Includes the values in the correct field in the temporary structure
  public static void setFieldData(String field, String value)  {
    if(field.equals("address"))
    {
      tmp_data.address = value;
      return;
    }
    if(field.equals("author"))
    {
      tmp_data.author = value;
      return;
    }
    if(field.equals("annote"))
    {
      tmp_data.annote = value;
      return;
    }
    if(field.equals("booktitle"))
    {
      tmp_data.booktitle = value;
      return;
    }
    if(field.equals("chapter"))
    {
      tmp_data.chapter = Integer.parseInt(value);
      return;
    }
    if(field.equals("crossref"))
    {
      tmp_data.crossref = value;
      return;
    }
    if(field.equals("edition"))
    {
      tmp_data.edition = value;
      return;
    }
    if(field.equals("editor"))
    {
      tmp_data.editor = value;
      return;
    }
    if(field.equals("howpublished"))
    {
      tmp_data.howpublished = value;
      return;
    }
    if(field.equals("institution"))
    {
      tmp_data.institution = value;
      return;
    }
    if(field.equals("journal"))
    {
      tmp_data.journal = value;
      return;
    }
    if(field.equals("key"))
    {
      tmp_data.key = value;
      return;
    }
    if(field.equals("month"))
    {
      tmp_data.month = value;
      return;
    }
    if(field.equals("note"))
    {
      tmp_data.note = value;
      return;
    }
    if(field.equals("number"))
    {
      tmp_data.number = Integer.parseInt(value);
      return;
    }
    if(field.equals("organization"))
    {
      tmp_data.organization = value;
      return;
    }
    if(field.equals("pages"))
    {
      tmp_data.pages = value;
      return;
    }
    if(field.equals("publisher"))
    {
      tmp_data.publisher = value;
      return;
    }
    if(field.equals("school"))
    {
      tmp_data.school = value;
      return;
    }
    if(field.equals("series"))
    {
      tmp_data.series = value;
      return;
    }
    if(field.equals("title"))
    {
      tmp_data.title = value;
      return;
    }
    if(field.equals("type"))
    {
      tmp_data.type = value;
      return;
    }
    if(field.equals("volume"))
    {
      tmp_data.volume = Integer.parseInt(value);
      return;
    }
    if(field.equals("year"))
    {
      tmp_data.year = value;
      return;
    }  }  public static void start(String file,String outputFolder)  {    tree = new Vector < Vector < Object >> ();    stack = new Stack < Object > ();
    keys = new Vector < String > ();
    HTMLout = new HTMLWriter(outputFolder);
    // Data control initialization
    count_data = 0;
    err_data = false;
    // ---
    int template = 1; // template selector var    String temp;    SymbolTable temp2;    try    {      if(bibParser != null)      {
        tree = new Vector < Vector < Object >> ();
	    stack = new Stack < Object > ();
	    keys = new Vector < String > ();
	    HTMLout = new HTMLWriter(outputFolder);
	    // Data control initialization
	    count_data = 0;
	    err_data = false;
	    bibParser = FileReader.getFile(file);
        BibParser.ReInit(bibParser);
      }
      else      {        bibParser = FileReader.getFile(file);
        new BibParser(bibParser); 
      }
      SimpleNode n = BibParser.Start();      n.dump(">>  ");      BibParser.CheckTree(n);      Enumeration t = symbtab.keys();      while (t.hasMoreElements() == true)      {        temp = (String) t.nextElement();        temp2 = (SymbolTable) symbtab.get(temp);
                //  System.out.println(temp);
        /*   if(temp2.type != null)
        	System.out.println(" type = " + temp2.type);
        if(temp2.value != null)
        	System.out.println(" value = " + temp2.value);*/      }
      // Create HTML
      HTMLout.removeQuotes();
      HTMLout.createHTML(template);    }    catch (Exception e)    {      System.err.println("Error: " + e.getMessage());    }  }}PARSER_END(BibParser)SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < ARROBA : "@" >| < BRACKET_START : "{" >| < BRACKET_END : "}" >| < COMMA : "," >| < EQUAL : "=" >| < DOUBLE_MARKS : "\"" >| < SINGLE_MARKS : "'" >| < STRING : "STRING" >| < ARTICLE : "ARTICLE" >| < BOOK : "BOOK" >| < BOOKLET : "BOOKLET" >| < CONFERENCE : "CONFERENCE" >| < INBOOK : "INBOOK" >| < INCOLLECTION : "INCOLLECTION" >| < INPROCEEDINGS : "INPROCEEDINGS" >| < MANUAL : "MANUAL" >| < MASTERSTHESIS : "MASTERSTHESIS" >| < MISC : "MISC" >| < PHDTHESIS : "PHDTHESIS" >| < PROCEEDINGS : "PROCEEDINGS" >| < TECHREPORT : "TECHREPORT" >| < UNPUBLISHED : "UNPUBLISHED" >| < AUTHOR : "AUTHOR" >| < ANNOTE : "ANNOTE" >| < BOOKTITLE : "BOOKTITLE" >| < CHAPTER : "CHAPTER" >| < CROSSREF : "CROSSREF" >| < EDITOR : "EDITOR" >| < INSTITUTION : "INSTITUTION" >| < ORGANIZATION : "ORGANIZATION" >| < SCHOOL : "SCHOOL" >| < JOURNAL : "JOURNAL" >| < TITLE : "TITLE" >| < YEAR : "YEAR" >| < VOLUME : "VOLUME" >| < NUMBER : "NUMBER" >| < ADDRESS : "ADDRESS" >| < HOWPUBLISHED : "HOWPUBLISHED" >| < PUBLISHER : "PUBLISHER" >| < SERIES : "SERIES" >| < EDITION : "EDITION" >| < PAGES : "PAGES" >| < PAGES_V :    < DOUBLE_MARKS > < INTEGER >    (      "-"    | "--"    )    < INTEGER > < DOUBLE_MARKS >  | < SINGLE_MARKS > < INTEGER >    (      "-"    | "--"    )    < INTEGER > < SINGLE_MARKS >>| < MONTH : "MONTH" >| < NOTE : "NOTE" >| < YEAR_V :    (      <DOUBLE_MARKS>  < INTEGER > ("?")? <DOUBLE_MARKS>     )  |    (      <SINGLE_MARKS> < INTEGER > ("?")? <SINGLE_MARKS>     ) >| < KEY : "KEY" >| < REP_TYPE : "REP_TYPE" >| < INTEGER : < DIGIT > (< DIGIT >)* >| < #DIGIT : [ "0"-"9" ] >| < QUOTED_TEXT :    < DOUBLE_MARKS >    (      < INTEGER >    | < LETTER >    | < SPECIAL >    | "\\"      (        < SINGLE_MARKS >      | < DOUBLE_MARKS >      )    | < SINGLE_MARKS >    )*    < DOUBLE_MARKS >  | < SINGLE_MARKS >    (      < INTEGER >    | < LETTER >    | < SPECIAL >    | "\\"      (        < SINGLE_MARKS >      | < DOUBLE_MARKS >      )    | < DOUBLE_MARKS >    )*    < SINGLE_MARKS >>| < WORD :    < LETTER >    (      < LETTER >    | < INTEGER >    )* >| < TEXT :    (      < LETTER >    | < INTEGER >    )+ >| < #SPECIAL : [ "\r", "\n", " "-"!", "#"-"&", "("-"/", ":"-"@", "["-"`", " "-"!", "{"-"~" ] >| < #LETTER : [ "A"-"z" ] >}void error_skipto(int kind) #void :{}{  {    ParseException e = generateParseException(); // generate the exception object.
    System.err.println(e.toString()); // print the error message
    Token t;    do    {      t = getNextToken();    }    while (t.kind != kind);  }}SimpleNode Start() :{}{  try  {    (Statement()) *    {      return jjtThis;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Statement() :{

  err_data = false;
  count_data++;
  tmp_data = new BibData();
  String type;
}{  try  {    Arroba() type = Type()
    {
      // Set the type intermediate structure
      tmp_data.setDataType(type);
    }
  	< BRACKET_START > Data() < BRACKET_END >
  	{
  	  // Insert previous read into intermediate structure only if it has no errors (in-case parser/syntax/semantic error skips)
  		if(count_data != 0 && !err_data)
  		{
  		  setTypeData(tmp_data.getDataType());
		}
  	}
  }   catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Arroba() :{}{  try  {    < ARROBA >  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Data() :{}{  try  {    Key() (Attribute() (Attribute()) *) ?  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Key() :{  Token key = null;}{  try  {    key = < WORD >    {      if (key == null)      {
        err_data = true;        System.err.println("Empty key");        throw new ParseException("Key is required");      }      else      {        jjtThis.jjtSetValue(key);        symbtab.put(key.image, new SymbolTable(key.kind, key.image));
        // Place in intermediate structure
        tmp_data.citationKey = key.image;      }    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Equal() :{}{  try  {    < EQUAL >  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Type() :{  Token value;}{  try  {    ((value = < WORD >)  | (value = < TEXT >)  | (value = < CONFERENCE >)  | (value = < ARTICLE >)  | (value = < BOOK >)  | (value = < BOOKLET >)  | (value = < INBOOK >)  | (value = < INCOLLECTION >)  | (value = < INPROCEEDINGS >)  | (value = < MANUAL >)  | (value = < MASTERSTHESIS >)  | (value = < MISC >)  | (value = < PHDTHESIS >)  | (value = < PROCEEDINGS >)  | (value = < TECHREPORT >)  | (value = < UNPUBLISHED >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Field() :{  Token value;}{  try  {    ((value = < AUTHOR >)  | (value = < ANNOTE >)  | (value = < BOOKTITLE >)  | (value = < CHAPTER >)  | (value = < CROSSREF >)  | (value = < EDITOR >)  | (value = < INSTITUTION >)  | (value = < ORGANIZATION >)  | (value = < SCHOOL >)  | (value = < JOURNAL >)  | (value = < TITLE >)  | (value = < YEAR >)  | (value = < VOLUME >)  | (value = < NUMBER >)  | (value = < ADDRESS >)  | (value = < HOWPUBLISHED >)  | (value = < PUBLISHER >)  | (value = < SERIES >)  | (value = < EDITION >)  | (value = < NOTE >)  | (value = < MONTH >)  | (value = < PAGES >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Value() :{  Token value;}{  try  {    ((value = < WORD >)  | (value = < QUOTED_TEXT >)  | (value = < INTEGER >)  | (value = < PAGES_V >)  | (value = < YEAR_V >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Attribute() :{
  String field;
  String value;
}{  try  {    (< COMMA > field = Field() Equal() value = Value())
    {
      // Place in the intermediate structure 
      setFieldData(field, value);    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void CheckTree(SimpleNode n) #void :{}{  {    if (n.id == BibParserTreeConstants.JJTSTATEMENT) checkStatement(n);    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn != null)        {          CheckTree(auxn);        }      }    }  }}void checkAttribute(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTFIELD || auxn.id == BibParserTreeConstants.JJTVALUE)        {          stack.push(auxn.jjtGetValue());        }      }    }  }}void checkData(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTKEY)        {          stack.push(auxn.jjtGetValue());        }        if (auxn.id == BibParserTreeConstants.JJTATTRIBUTE)        {          checkAttribute(auxn);        }      }      analyzeStack();    }  }}void checkType(SimpleNode n) #void :{}{  {    if (!(((Token) n.jjtGetValue()).kind == BibParserConstants.ARTICLE || ((Token) n.jjtGetValue()).kind == BibParserConstants.BOOK || ((Token) n.jjtGetValue()).kind == BibParserConstants.BOOKLET || ((Token) n.jjtGetValue()).kind == BibParserConstants.CONFERENCE || ((Token) n.jjtGetValue()).kind == BibParserConstants.INBOOK || ((Token) n.jjtGetValue()).kind == BibParserConstants.INCOLLECTION || ((Token) n.jjtGetValue()).kind == BibParserConstants.INPROCEEDINGS || ((Token) n.jjtGetValue()).kind == BibParserConstants.MANUAL || ((Token) n.jjtGetValue()).kind == BibParserConstants.MASTERSTHESIS || ((Token) n.jjtGetValue()).kind == BibParserConstants.MISC || ((Token) n.jjtGetValue()).kind == BibParserConstants.PHDTHESIS || ((Token) n.jjtGetValue()).kind == BibParserConstants.PROCEEDINGS || ((Token) n.jjtGetValue()).kind == BibParserConstants.TECHREPORT || ((Token) n.jjtGetValue()).kind == BibParserConstants.UNPUBLISHED))    {      System.err.println("No such type");    }    else    {      stack.push((Token) n.jjtGetValue());    }  }}void checkStatement(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTTYPE)        {          checkType(auxn);        }        if (auxn.id == BibParserTreeConstants.JJTDATA)        {          checkData(auxn);        }      }    }  }}void analyzeStack() #void :{}{  {    Vector < Object > stackelems = new Vector < Object > ();    while (!stack.empty())    {      stackelems.addElement(stack.peek());      stack.pop();    }    Collections.reverse(stackelems);    switch (((Token) stackelems.elementAt(0)).kind)    {      case BibParserConstants.ARTICLE : case BibParserConstants.BOOK : case BibParserConstants.BOOKLET : case BibParserConstants.CONFERENCE : case BibParserConstants.INBOOK : case BibParserConstants.INCOLLECTION : case BibParserConstants.INPROCEEDINGS : case BibParserConstants.MANUAL : case BibParserConstants.MASTERSTHESIS : case BibParserConstants.MISC : case BibParserConstants.PHDTHESIS : case BibParserConstants.PROCEEDINGS : case BibParserConstants.TECHREPORT : case BibParserConstants.UNPUBLISHED : analyzeType(stackelems, ((Token) stackelems.elementAt(0)).kind);      break;    }  }}void analyzeType(Vector < Object > elems, int type) #void :{}{  {    int currPairInd = 0;    int numPair = (elems.size() - 1) / 2;    Token key = (Token) elems.elementAt(1);
    keys.add(key.image);    elems.remove(1);    int [ ] types = new int [ numPair ];    Token [ ] values = new Token [ numPair ];    for (int i = 0; i < numPair; i++)    {      values [ i ] = new Token();    }    for (int i = 1; i < elems.size(); i += 2)    {      types [ currPairInd ] = ((Token) elems.elementAt(i)).kind;      values [ currPairInd ] = (Token) elems.elementAt(i + 1);      currPairInd++;    }    try    {
    for ( int i = 0 ; i<keys.size()-1;i++)
    {
		if(keys.elementAt(i).equals(key.image))
			throw new SemanticException("ERROR: repeated key found " + key.image);
				
    }      for (int i = 0; i < numPair; i++)      {        for (int j = i + 1; j < numPair; j++)        {          if (types [ i ] == types[ j ])          {            throw new SemanticException("ERROR: repeated field found in entry " + key.image);          }        }      }    }    catch (SemanticException e)    {
      err_data = true;      System.err.println(e.getMessage());    }    try    {      switch (type)      {        case BibParserConstants.ARTICLE : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.JOURNAL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in ARTICLE " + key.image);        }        break;        case BibParserConstants.BOOK : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in BOOK " + key.image);        }        break;        case BibParserConstants.BOOKLET : if (!Utilities.contains(types, BibParserConstants.TITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in BOOKLET " + key.image);        }        break;        case BibParserConstants.CONFERENCE : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.BOOKTITLE) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in CONFERENCE " + key.image);        }        break;        case BibParserConstants.INBOOK : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.CHAPTER))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INBOOK " + key.image);        }        break;        case BibParserConstants.INCOLLECTION : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.BOOKTITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INCOLLECTION " + key.image);        }        break;        case BibParserConstants.INPROCEEDINGS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.BOOKTITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INPROCEEDINGS " + key.image);        }        break;        case BibParserConstants.MANUAL : if (!Utilities.contains(types, BibParserConstants.TITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MANUAL " + key.image);        }        break;        case BibParserConstants.MASTERSTHESIS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.SCHOOL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MASTERSTHESIS " + key.image);        }        break;        case BibParserConstants.MISC : /* NOT NEEDED */ /*if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.HOWPUBLISHED) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.MONTH) || !Utilities.contains(types, BibParserConstants.NOTE) || !Utilities.contains(types, BibParserConstants.KEY))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MISC " + key.image);        }*/        break;        case BibParserConstants.PHDTHESIS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.SCHOOL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in PHDTHESIS " + key.image);        }        break;        case BibParserConstants.PROCEEDINGS : if (!Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in PROCEDINGS " + key.image);        }        break;        case BibParserConstants.TECHREPORT : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.INSTITUTION) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in TECHREPORT " + key.image);        }        break;        case BibParserConstants.UNPUBLISHED : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.NOTE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in UNPUBLISHED " + key.image);        }        break;        default : break;      }    }    catch (SemanticException e)    {
      err_data = true;      System.err.println(e.getMessage());    }    checkValueTypes(types, values, numPair, key);  }}void checkValueTypes(int [ ] types, Token [ ] values, int numPair, Token key) #void :{}{  {    SymbolTable st;    for (int i = 0; i < numPair; i++)    {      try      {        switch (types [ i ])        {          case BibParserConstants.ADDRESS : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ADDRESS at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.ANNOTE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ANNOTE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.AUTHOR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of AUTHOR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.BOOKTITLE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of BOOKTITLE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.CHAPTER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of CHAPTER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.CROSSREF : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;	            throw new SemanticException("Wrong value of CROSSREF at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }
          else          {			String temp = "";
			temp = values[i].image.replace("\"","");
			st = (SymbolTable) symbtab.get(temp);
			if(st == null)			{			  err_data = true;
			  throw new SemanticException("CROSSREF Error: Key " + temp + " does not exist in input file, at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);
			}
          }          break;          case BibParserConstants.EDITION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of EDITION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.EDITOR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of EDITOR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.HOWPUBLISHED : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of HOWPUBLISHED at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.INSTITUTION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of INSTITUTION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.JOURNAL : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))          {
            err_data = true;            throw new SemanticException("Wrong value of JOURNAL at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.MONTH : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of MONTH at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.NOTE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of NOTE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.NUMBER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of NUMBER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.ORGANIZATION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ORGANIZATION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.PAGES : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of PAGES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          else if (!PagesControl.verifyPages(values [ i ].image))          {
            err_data = true;            throw new SemanticException("Wrong value of PAGES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.PUBLISHER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of PUBLISHER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.SCHOOL : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of SCHOOL at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.SERIES : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of SERIES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.REP_TYPE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of TYPE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.YEAR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER) && !(st.type == BibParserConstants.YEAR_V) && !(st.type == BibParserConstants.PAGES_V))          {
            err_data = true;            throw new SemanticException("Wrong value of YEAR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.VOLUME : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of VOLUME at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.KEY : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of KEY at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.TITLE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))          {
            err_data = true;            throw new SemanticException("Wrong value of TITLE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          default :
          {
            err_data = true;            throw new SemanticException("unknown or incorrect field found at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " : " + values [ i ].image + "in entry " + key.image);          }
          break;        }      }      catch (SemanticException e)      {
        err_data = true;        System.err.println("Semantic error: " + e.getMessage());      }    }  }}

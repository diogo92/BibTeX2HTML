/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  IGNORE_CASE = true;
  UNICODE_INPUT = true;
  FORCE_LA_CHECK = true;
  lookahead = 10;}PARSER_BEGIN(BibParser)package parser;

import java.util.Vector;
import java.util.Scanner;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import data.*;
import reader.FileReader;
import utils.*;

public class BibParser{
  public static Hashtable symbtab = new Hashtable();
  public static Vector< BibData > data;
  public static Vector< Vector <Object > > tree;
  public static Stack<Object > stack;
  public static boolean firstStack = true;
  public static int currIndex = 0;
  public static void main(String args [])
    {	start(args);
  }  public static void start(String args [])  {
    tree = new Vector< Vector <Object > >();
    stack = new Stack<Object >();
    String temp;
    SymbolTable temp2;    System.out.println("File to be parsed:");    System.out.print(">> ");
    Scanner sc = new Scanner(System.in);
    String file = sc.nextLine();
        try    {
      new BibParser(FileReader.getFile(file));
      SimpleNode n = BibParser.Start();      n.dump(">>  ");
      BibParser.CheckTree(n);
      Enumeration t = symbtab.keys();

      while (t.hasMoreElements() == true)      {
        temp = (String)t.nextElement();
        temp2 = (SymbolTable)symbtab.get(temp);
      //  System.out.println(temp);
     /*   if(temp2.type != null)
        	System.out.println(" type = " + temp2.type);
        if(temp2.value != null)
        	System.out.println(" value = " + temp2.value);*/

      }    }    catch (Exception e)    {      System.err.println("Error: " + e.getMessage());    }
    sc.close();  }

  }PARSER_END(BibParser)SKIP :{  " "| "\t"| "\r"
| "\n"}
TOKEN :{
  < ARROBA : "@" >
| < BRACKET_START : "{" >
| < BRACKET_END : "}" >
| < COMMA : "," >
| < EQUAL : "=" >
| < DOUBLE_MARKS :"\"" >
| < SINGLE_MARKS :"'" >
| < STRING : "STRING" >
| < ARTICLE : "ARTICLE" >
| < BOOK : "BOOK" >
| < BOOKLET : "BOOKLET" >
| < CONFERENCE : "CONFERENCE" >
| < INBOOK : "INBOOK" >
| < INCOLLECTION : "INCOLLECTION" >
| < INPROCEEDINGS : "INPROCEEDINGS" >
| < MANUAL : "MANUAL" >
| < MASTERTHESIS : "MASTERTHESIS" >
| < MISC : "MISC" >
| < PHDTHESIS : "PHDTHESIS" >
| < PROCEEDINGS : "PROCEEDINGS" >
| < TECHREPORT : "TECHREPORT" >
| < UNPUBLISHED : "UNPUBLISHED" >
| < AUTHOR : "AUTHOR" >
| < ANNOTE : "ANNOTE" >
| < BOOKTITLE : "BOOKTITLE" >
| < CHAPTER : "CHAPTER" >
| < CROSSREF : "CROSSREF" >
| < EDITOR : "EDITOR" >
| < INSTITUTION : "INSTITUTION" >
| < ORGANIZATION : "ORGANIZATION" >
| < SCHOOL : "SCHOOL" >
| < JOURNAL : "JOURNAL" >
| < TITLE : "TITLE" >
| < YEAR : "YEAR" >
| < VOLUME : "VOLUME" >
| < NUMBER : "NUMBER" >
| < ADDRESS : "ADDRESS" >
| < HOWPUBLISHED : "HOWPUBLISHED" >
| < PUBLISHER : "PUBLISHER" >
| < SERIES : "SERIES" >
| < EDITION: "EDITION" >
| < PAGES : "PAGES" >
| < PAGES_V : < DOUBLE_MARKS >< INTEGER > ("-"|"--") < INTEGER ><DOUBLE_MARKS > |< SINGLE_MARKS >< INTEGER > ("-"|"--") < INTEGER ><SINGLE_MARKS > >
| < MONTH : "MONTH" >
| < NOTE : "NOTE" >
| < YEAR_V : ("\"" < INTEGER > ("?")? "\"") | ("'" < INTEGER > ("?")? "'")>
| < KEY : "KEY" >
| < REP_TYPE : "REP_TYPE" >
| < INTEGER : < DIGIT >(< DIGIT >)* >
| < #DIGIT : ["0"-"9"] >
| < QUOTED_TEXT : < DOUBLE_MARKS > (< INTEGER > | < LETTER > | < SPECIAL > | "\\" (< SINGLE_MARKS >| < DOUBLE_MARKS >) | < SINGLE_MARKS >)*< DOUBLE_MARKS > | < SINGLE_MARKS >(< INTEGER > | < LETTER > | < SPECIAL > | "\\" (< SINGLE_MARKS >| < DOUBLE_MARKS >)| < DOUBLE_MARKS >)*< SINGLE_MARKS > > 
| < WORD : < LETTER >(< LETTER > | < INTEGER >)* >
| < TEXT : (< LETTER > | < INTEGER >)+ >
| < #SPECIAL : ["\r","\n","\u0020"-"\u0021","\u0023"-"\u0026","\u0028"-"\u002f",
				"\u003a"-"\u0040" ,"\u005b"-"\u0060","\u0020"-"\u0021","\u007b"-"\u007e"
				] >
| < #LETTER : ["\u0041"-"\u007A" ] >
}

void error_skipto(int kind) #void:
{}{
  {	  ParseException e = generateParseException();  // generate the exception object.
	  System.err.println(e.toString());  // print the error message
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind);
  }
}SimpleNode Start() :{
}{
  try {
    (
    Arroba() Type() < BRACKET_START > Data() < BRACKET_END >
	  )*
	  {
	    return jjtThis;
	  }
	}
  catch (ParseException e) {
    error_skipto(BibParserConstants.BRACKET_END);
  }}

void Arroba() :
{}
{
  try  {	< ARROBA >
  } catch (ParseException e) {
    error_skipto(BibParserConstants.BRACKET_END);
  }
}

void Data() :
{}
{
  try  {
  Key() (Attribute() (< COMMA > Attribute() )*)?
  } catch (ParseException e)  {	error_skipto(BibParserConstants.BRACKET_END);
  }}

void Key() :
{
  Token key = null;}
{
  	try  	{	(key = < WORD > < COMMA >)?

	{
	  
	  if(key == null)
	  {		System.out.println("Empty key");
	  }
	  else
	  {jjtThis.jjtSetValue(key);symbtab.put(key.image,new SymbolTable(key.kind,key.image));}
	}
	}catch (ParseException e)
	  {
		error_skipto(BibParserConstants.BRACKET_END);
	  }}

void Equal() :{}
{
  try  {
  < EQUAL >
  }
  catch (ParseException e)
  {
	error_skipto(BibParserConstants.BRACKET_END);
  }}

void Type() :
{
	Token value;
}
{
  try  {    
  (    
	(value=< WORD >	) |	(value=< TEXT >	) |	(value=< CONFERENCE >) | (value=< ARTICLE >	) |
	(value=< BOOK >	) |	(value=< BOOKLET >) |	(value=< INBOOK >) | (value=< INCOLLECTION >) |
	(value=< INPROCEEDINGS >) |	(value=< MANUAL >) | (value=< MASTERTHESIS >) |	(value=< MISC >) |
	(value=< PHDTHESIS >)| (value=< PROCEEDINGS >	) |	(value=< TECHREPORT >	) |	(value=< UNPUBLISHED >)
  )
	{jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
}catch (ParseException e)
  {
	error_skipto(BibParserConstants.BRACKET_END);
  }
}

void Field():
{
  Token value;
}
{
  try  {    
  (    	(value=< AUTHOR >) | (value=< ANNOTE >) | (value=< BOOKTITLE >) | (value=< CHAPTER >)
	| (value=< CROSSREF >) | (value=< EDITOR >) | (value=< INSTITUTION >) | (value=< ORGANIZATION >	)
	| (value=< SCHOOL >	) | (value=< JOURNAL >) | (value=< TITLE >) | (value=< YEAR >) | (value=< VOLUME >)
	| (value=< NUMBER >	) | (value=< ADDRESS >) | (value=< HOWPUBLISHED >) | (value=< PUBLISHER >	)
	| (value=< SERIES >) | (value=< EDITION >) | (value=< NOTE >) | (value=< MONTH >) | (value=< PAGES >)
  )
  {jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
}catch (ParseException e)
  {
	error_skipto(BibParserConstants.BRACKET_END);
  }
}
void Value() :
{
  Token value;}{
  try  {    
  (    
	(value=< WORD >) | (value=< QUOTED_TEXT >) | (value=< INTEGER >) | (value=< PAGES_V >) | (value=< YEAR_V >)

  )
  {jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
}catch (ParseException e)
  {
	error_skipto(BibParserConstants.BRACKET_END);
  }
	}

void Attribute():
{
}
{
  try  {
  (
  		Field() Equal() Value()
  )
  } catch (ParseException e)
  {
	error_skipto(BibParserConstants.BRACKET_END);
  }
}


void CheckTree(SimpleNode n) #void:
{}
{    {
	if(((Token)n.jjtGetValue())!=null)	{		if(((Token)n.jjtGetValue()).kind == BibParserConstants.ARTICLE || ((Token)n.jjtGetValue()).kind == BibParserConstants.BOOK || ((Token)n.jjtGetValue()).kind == BibParserConstants.BOOKLET ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.CONFERENCE || ((Token)n.jjtGetValue()).kind == BibParserConstants.INBOOK || ((Token)n.jjtGetValue()).kind == BibParserConstants.INCOLLECTION ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.INPROCEEDINGS || ((Token)n.jjtGetValue()).kind == BibParserConstants.MANUAL || ((Token)n.jjtGetValue()).kind == BibParserConstants.MASTERTHESIS ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.MISC || ((Token)n.jjtGetValue()).kind == BibParserConstants.PHDTHESIS || ((Token)n.jjtGetValue()).kind == BibParserConstants.PROCEEDINGS ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.TECHREPORT || ((Token)n.jjtGetValue()).kind == BibParserConstants.UNPUBLISHED)			{

			  	if(!firstStack)			  	{					analyzeStack();
			  	}
			  	if(firstStack)
			  		firstStack=false;
			  	stack.push(n.jjtGetValue());
			}
		else		{			stack.push(n.jjtGetValue());
		}
	}
    if (n.jjtGetNumChildren() > 0) {
      for (int i = 0; i < n.jjtGetNumChildren(); ++i) {
        SimpleNode auxn = (SimpleNode)n.jjtGetChild(i);
        if (auxn != null) {
         CheckTree(auxn);
        }
      }
    }
       
  }
}

void analyzeStack() #void:
{}{
  {
    Vector <Object > stackelems = new Vector<Object >();
    while(!stack.empty())    {		stackelems.addElement(stack.peek());
		stack.pop();
    }
   	Collections.reverse(stackelems);
   	switch(((Token)stackelems.elementAt(0)).kind)   	{		case BibParserConstants.ARTICLE:
		case BibParserConstants.BOOK:
		case BibParserConstants.BOOKLET:
		case BibParserConstants.CONFERENCE:
		case BibParserConstants.INBOOK:
		case BibParserConstants.INCOLLECTION:
		case BibParserConstants.INPROCEEDINGS:
		case BibParserConstants.MANUAL:
		case BibParserConstants.MASTERTHESIS:
		case BibParserConstants.MISC:
		case BibParserConstants.PHDTHESIS:
		case BibParserConstants.PROCEEDINGS:
		case BibParserConstants.TECHREPORT:
		case BibParserConstants.UNPUBLISHED:
			analyzeType(stackelems,((Token)stackelems.elementAt(0)).kind);
			break;

   	}  }}


void analyzeType(Vector<Object > elems,int type) #void:
{}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    Token key = (Token)elems.elementAt(1);
    elems.remove(1);
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    switch(type)    {
      case BibParserConstants.ARTICLE:
	    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.JOURNAL) ||
	    	!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN ARTICLE " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.BOOK:
	    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
	    	!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN BOOK " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.BOOKLET:
        if(!Utilities.contains(types,BibParserConstants.TITLE))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN BOOKLET " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.CONFERENCE:
      	if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.BOOKTITLE) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN CONFERENCE " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.INBOOK:
      	if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.CHAPTER))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INBOOK " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.INCOLLECTION:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.BOOKTITLE))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INCOLLECTION " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.INPROCEEDINGS:
      	if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.BOOKTITLE))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INPROCEEDINGS " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.MANUAL:
        if(!Utilities.contains(types,BibParserConstants.TITLE))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MANUAL " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.MASTERTHESIS:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.SCHOOL) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MASTERSTHESIS " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.MISC:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.HOWPUBLISHED) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.MONTH) || !Utilities.contains(types,BibParserConstants.NOTE) || !Utilities.contains(types,BibParserConstants.KEY))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MISC " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.PHDTHESIS:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.SCHOOL) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN PHDTHESIS " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.PROCEEDINGS:
        if(!Utilities.contains(types,BibParserConstants.TITLE) ||!Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN PROCEDINGS " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.TECHREPORT:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.INSTITUTION) ||
	    !Utilities.contains(types,BibParserConstants.YEAR))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN TECHREPORT " + key.image);
			System.exit(-1);
	    }
      	break;
      case BibParserConstants.UNPUBLISHED:
        if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.NOTE))
	    {
			System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN UNPUBLISHED " + key.image);
			System.exit(-1);
	    }
      	break;
      default:
      	break;
    }
    checkValueTypes(types,values,numPair, key);
  }
}

void checkValueTypes(int[] types,Token[] values,int numPair, Token key) #void:{}{
  {
    SymbolTable st;
    for(int i=0;i<numPair;i++)
    {
      try      { 
		switch (types[i])
		{
		  	case BibParserConstants.ADDRESS:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF ADDRESS AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.ANNOTE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF ANNOTE AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.AUTHOR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF AUTHOR AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.BOOKTITLE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF BOOKTITLE AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.CHAPTER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER))
				{
					throw new SemanticException("WRONG VALUE OF CHAPTER AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.CROSSREF:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.WORD))
				{
					throw new SemanticException("WRONG VALUE OF CROSSREF AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.EDITION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF EDITION AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.EDITOR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF EDITOR AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.HOWPUBLISHED:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF HOWPUBLISHED AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.INSTITUTION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF INSTITUTION AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.JOURNAL:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))
				{
					throw new SemanticException("WRONG VALUE OF JOURNAL AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.MONTH:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF MONTH AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.NOTE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF NOTE AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.NUMBER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER))
				{
					throw new SemanticException("WRONG VALUE OF NUMBER AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.ORGANIZATION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF ORGANIZATION AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.PAGES:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))
				{
					throw new SemanticException("WRONG VALUE OF PAGES AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.PUBLISHER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF PUBLISHER AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.SCHOOL:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF SCHOOL AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.SERIES:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF SERIES AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.REP_TYPE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF TYPE AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.YEAR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER) && !(st.type == BibParserConstants.YEAR_V) && !(st.type == BibParserConstants.PAGES_V))
				{
					throw new SemanticException("WRONG VALUE OF YEAR AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.VOLUME:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))
				{
					throw new SemanticException("WRONG VALUE OF VOLUME AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.KEY:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					throw new SemanticException("WRONG VALUE OF KEY AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			case BibParserConstants.TITLE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))
				{
					throw new SemanticException("WRONG VALUE OF TITLE AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + "IN ENTRY " + key.image);
				}
				break;
			default:
				throw new SemanticException("UNKNOWN OR INCORRECT FIELD FOUND AT LINE " + values[i].beginLine + " COLUMN " + values[i].beginColumn + " : " + values[i].image  + "IN ENTRY " + key.image);
				break;
		}
	  } catch (SemanticException e) {		System.err.println("Semantic error: " + e.getMessage());
	  }
    }  }}


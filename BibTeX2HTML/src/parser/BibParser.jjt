/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  IGNORE_CASE = true;
  UNICODE_INPUT = true;
  FORCE_LA_CHECK = true;
  lookahead = 10;}PARSER_BEGIN(BibParser)package parser;

import java.util.Vector;
import java.util.Scanner;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import data.*;
import reader.FileReader;
import utils.*;

public class BibParser{
  public static Hashtable symbtab = new Hashtable();
  public static Vector< BibData > data;
  public static Vector< Vector <Object > > tree;
  public static Stack<Object > stack;
  public static boolean firstStack = true;
  public static int currIndex = 0;
  public static void main(String args [])
    {	start(args);
  }  public static void start(String args [])  {
    tree = new Vector< Vector <Object > >();
    stack = new Stack<Object >();
    String temp;
    SymbolTable temp2;    System.out.println("File to be parsed:");    System.out.print(">> ");
    Scanner sc = new Scanner(System.in);
    String file = sc.nextLine();
        try    {
      new BibParser(FileReader.getFile(file));
      SimpleNode n = BibParser.Start();      n.dump(">>  ");
      BibParser.CheckTree(n);
      Enumeration t = symbtab.keys();

      while (t.hasMoreElements() == true)      {
        temp = (String)t.nextElement();
        temp2 = (SymbolTable)symbtab.get(temp);
      //  System.out.println(temp);
     /*   if(temp2.type != null)
        	System.out.println(" type = " + temp2.type);
        if(temp2.value != null)
        	System.out.println(" value = " + temp2.value);*/

      }    }    catch (Exception e)    {      System.out.println("Error: " + e.getMessage());    }
    sc.close();  }

  }PARSER_END(BibParser)SKIP :{  " "| "\t"| "\r"
| "\n"}
TOKEN :{
  < ARROBA : "@" >
| < BRACKET_START : "{" >
| < BRACKET_END : "}" >
| < COMMA : "," >
| < EQUAL : "=" >
| < DOUBLE_MARKS :"\"" >
| < SINGLE_MARKS :"'" >
| < STRING : "STRING" >
| < ARTICLE : "ARTICLE" >
| < BOOK : "BOOK" >
| < BOOKLET : "BOOKLET" >
| < CONFERENCE : "CONFERENCE" >
| < INBOOK : "INBOOK" >
| < INCOLLECTION : "INCOLLECTION" >
| < INPROCEEDINGS : "INPROCEEDINGS" >
| < MANUAL : "MANUAL" >
| < MASTERTHESIS : "MASTERTHESIS" >
| < MISC : "MISC" >
| < PHDTHESIS : "PHDTHESIS" >
| < PROCEEDINGS : "PROCEEDINGS" >
| < TECHREPORT : "TECHREPORT" >
| < UNPUBLISHED : "UNPUBLISHED" >
| < AUTHOR : "AUTHOR" >
| < ANNOTE : "ANNOTE" >
| < BOOKTITLE : "BOOKTITLE" >
| < CHAPTER : "CHAPTER" >
| < CROSSREF : "CROSSREF" >
| < EDITOR : "EDITOR" >
| < INSTITUTION : "INSTITUTION" >
| < ORGANIZATION : "ORGANIZATION" >
| < SCHOOL : "SCHOOL" >
| < JOURNAL : "JOURNAL" >
| < TITLE : "TITLE" >
| < YEAR : "YEAR" >
| < VOLUME : "VOLUME" >
| < NUMBER : "NUMBER" >
| < ADDRESS : "ADDRESS" >
| < HOWPUBLISHED : "HOWPUBLISHED" >
| < PUBLISHER : "PUBLISHER" >
| < SERIES : "SERIES" >
| < EDITION: "EDITION" >
| < PAGES : "PAGES" >
| < PAGES_V : < DOUBLE_MARKS >< INTEGER > ("-"|"--") < INTEGER ><DOUBLE_MARKS > |< SINGLE_MARKS >< INTEGER > ("-"|"--") < INTEGER ><SINGLE_MARKS > >
| < MONTH : "MONTH" >
| < NOTE : "NOTE" >
| < YEAR_V : ("\"" < INTEGER > ("?")? "\"") | ("'" < INTEGER > ("?")? "'")>
| < KEY : "KEY" >
| < REP_TYPE : "REP_TYPE" >
| < INTEGER : < DIGIT >(< DIGIT >)* >
| < #DIGIT : ["0"-"9"] >
| < QUOTED_TEXT : < DOUBLE_MARKS > (< INTEGER > | < LETTER > | < SPECIAL > | "\\" (< SINGLE_MARKS >| < DOUBLE_MARKS >) | < SINGLE_MARKS >)*< DOUBLE_MARKS > | < SINGLE_MARKS >(< INTEGER > | < LETTER > | < SPECIAL > | "\\" (< SINGLE_MARKS >| < DOUBLE_MARKS >)| < DOUBLE_MARKS >)*< SINGLE_MARKS > > 
| < WORD : < LETTER >(< LETTER > | < INTEGER >)* >
| < TEXT : (< LETTER > | < INTEGER >)+ >
| < #SPECIAL : ["\r","\n","\u0020"-"\u0021","\u0023"-"\u0026","\u0028"-"\u002f",
				"\u003a"-"\u0040" ,"\u005b"-"\u0060","\u0020"-"\u0021","\u007b"-"\u007e"
				] >
| < #LETTER : ["\u0041"-"\u007A" ] >
}SimpleNode Start() :{
}{  (    Arroba() Type() < BRACKET_START > Data() < BRACKET_END >
  )*  {    return jjtThis;  }}

void Arroba() :
{}
{	< ARROBA >
}

void Data() :
{}
{
  Key() (Attribute() (< COMMA > Attribute() )*)? }

void Key() :
{
  Token key = null;}
{	(key = < WORD > < COMMA >)?

	{
	  if(key == null)
	  {		System.out.println("Empty key");
	  }
	}}

void Equal() :{}
{
  < EQUAL >}

void Type() :
{
	Token value;
}
{
  (    
	(value=< WORD >	) |
	(value=< TEXT >	) |
	(value=< CONFERENCE >) |
	(value=< ARTICLE >	) |
	(value=< BOOK >	) |
	(value=< BOOKLET >) |
	(value=< INBOOK >) |
	(value=< INCOLLECTION >) |
	(value=< INPROCEEDINGS >) |
	(value=< MANUAL >) |
	(value=< MASTERTHESIS >) |
	(value=< MISC >) |
	(value=< PHDTHESIS >)|
	(value=< PROCEEDINGS >	) |
	(value=< TECHREPORT >	) |
	(value=< UNPUBLISHED >)
)
	{jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
}

void Field():
{
  Token value;
}
{
  (    	(value=< AUTHOR >) | (value=< ANNOTE >) | (value=< BOOKTITLE >) | (value=< CHAPTER >)
	| (value=< CROSSREF >) | (value=< EDITOR >) | (value=< INSTITUTION >) | (value=< ORGANIZATION >	)
	| (value=< SCHOOL >	) | (value=< JOURNAL >) | (value=< TITLE >) | (value=< YEAR >) | (value=< VOLUME >)
	| (value=< NUMBER >	) | (value=< ADDRESS >) | (value=< HOWPUBLISHED >) | (value=< PUBLISHER >	)
	| (value=< SERIES >) | (value=< EDITION >) | (value=< NOTE >) | (value=< MONTH >) | (value=< PAGES >)
  )
  {jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
}
void Value() :
{
  Token value;}{
  (    
	(value=< WORD >) | (value=< QUOTED_TEXT >) | (value=< INTEGER >) | (value=< PAGES_V >) | (value=< YEAR_V >)

  )
  {jjtThis.jjtSetValue(value);symbtab.put(value.image,new SymbolTable(value.kind,value.image));}
	}

void Attribute():
{
}
{
  (
  		Field() Equal() Value()
  )
}


void CheckTree(SimpleNode n) #void:
{}
{    {
	if(((Token)n.jjtGetValue())!=null)	{		if(((Token)n.jjtGetValue()).kind == BibParserConstants.ARTICLE || ((Token)n.jjtGetValue()).kind == BibParserConstants.BOOK || ((Token)n.jjtGetValue()).kind == BibParserConstants.BOOKLET ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.CONFERENCE || ((Token)n.jjtGetValue()).kind == BibParserConstants.INBOOK || ((Token)n.jjtGetValue()).kind == BibParserConstants.INCOLLECTION ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.INPROCEEDINGS || ((Token)n.jjtGetValue()).kind == BibParserConstants.MANUAL || ((Token)n.jjtGetValue()).kind == BibParserConstants.MASTERTHESIS ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.MISC || ((Token)n.jjtGetValue()).kind == BibParserConstants.PHDTHESIS || ((Token)n.jjtGetValue()).kind == BibParserConstants.PROCEEDINGS ||
			((Token)n.jjtGetValue()).kind == BibParserConstants.TECHREPORT || ((Token)n.jjtGetValue()).kind == BibParserConstants.UNPUBLISHED)			{

			  	if(!firstStack)			  	{					analyzeStack();
			  	}
			  	if(firstStack)
			  		firstStack=false;
			  	stack.push(n.jjtGetValue());
			}
		else		{			stack.push(n.jjtGetValue());
		}
	}
    if (n.jjtGetNumChildren() > 0) {
      for (int i = 0; i < n.jjtGetNumChildren(); ++i) {
        SimpleNode auxn = (SimpleNode)n.jjtGetChild(i);
        if (auxn != null) {
         CheckTree(auxn);
        }
      }
    }
       
  }
}

void analyzeStack() #void:
{}{
  {
    Vector <Object > stackelems = new Vector<Object >();
    while(!stack.empty())    {		stackelems.addElement(stack.peek());
		stack.pop();
    }
   	Collections.reverse(stackelems);
   	switch(((Token)stackelems.elementAt(0)).kind)   	{		case BibParserConstants.ARTICLE:
		analyzeArticle(stackelems);
		break;

		case BibParserConstants.BOOK:
		analyzeBook(stackelems);
		break;

		case BibParserConstants.BOOKLET:
		analyzeBooklet(stackelems);
		break;

		case BibParserConstants.CONFERENCE:
		analyzeConference(stackelems);
		break;

		case BibParserConstants.INBOOK:
		analyzeInbook(stackelems);
		break;

		case BibParserConstants.INCOLLECTION:
		analyzeIncollection(stackelems);
		break;

		case BibParserConstants.INPROCEEDINGS:
		analyzeInproceedings(stackelems);
		break;

		case BibParserConstants.MANUAL:
		analyzeManual(stackelems);
		break;

		case BibParserConstants.MASTERTHESIS:
		analyzeMastersthesis(stackelems);
		break;

		case BibParserConstants.MISC:
		analyzeMisc(stackelems);
		break;

		case BibParserConstants.PHDTHESIS:
		analyzePhdthesis(stackelems);
		break;

		case BibParserConstants.PROCEEDINGS:
		analyzeProceedings(stackelems);
		break;

		case BibParserConstants.TECHREPORT:
		analyzeTechreport(stackelems);
		break;

		case BibParserConstants.UNPUBLISHED:
		analyzeUnpublished(stackelems);
		break;

   	}  }}


void analyzeArticle(Vector<Object > elems) #void:
{}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.JOURNAL) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))    {		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN ARTICLE " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);
  }}

void analyzeBook(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN BOOK " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeBooklet(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.TITLE))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN BOOKLET " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeConference(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.BOOKTITLE) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN CONFERENCE " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeInbook(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.CHAPTER))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INBOOK " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeIncollection(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.PUBLISHER) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.BOOKTITLE))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INCOLLECTION " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeInproceedings(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.BOOKTITLE))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN INPROCEEDINGS " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeManual(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.TITLE))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MANUAL " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeMastersthesis(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.SCHOOL) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MASTERSTHESIS " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeMisc(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.HOWPUBLISHED) ||
    	!Utilities.contains(types,BibParserConstants.YEAR) || !Utilities.contains(types,BibParserConstants.MONTH) || !Utilities.contains(types,BibParserConstants.NOTE) || !Utilities.contains(types,BibParserConstants.KEY))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN MISC " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzePhdthesis(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.SCHOOL) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN PHDTHESIS " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeProceedings(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.TITLE) ||!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN PROCEDINGS " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeTechreport(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.INSTITUTION) ||
    	!Utilities.contains(types,BibParserConstants.YEAR))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN TECHREPORT " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}

void analyzeUnpublished(Vector<Object > elems) #void:
{
}
{
  {
    int currPairInd = 0;
    int numPair = (elems.size()-1)/2;
    int[] types = new int[numPair];
    Token[] values = new Token[numPair];
    for(int i= 0;i<numPair;i++)
    {
		values[i] = new Token();
    }
    for(int i = 1; i<elems.size();i+=2)
    {
		types[currPairInd]=((Token)elems.elementAt(i)).kind;
		values[currPairInd]=(Token)elems.elementAt(i+1);
   		currPairInd++;
    }
    if(!Utilities.contains(types,BibParserConstants.AUTHOR) || !Utilities.contains(types,BibParserConstants.TITLE) || !Utilities.contains(types,BibParserConstants.NOTE))
    {
		System.out.println("ERROR: REQUIRED FIELD NOT PRESENT IN UNPUBLISHED " /*+ INSERIR CHAVE*/);
		System.exit(-1);
    }
    checkValueTypes(types,values,numPair);

  }
}


void checkValueTypes(int[] types,Token[] values,int numPair) #void:{}{
  {
    SymbolTable st;
    for(int i=0;i<numPair;i++)
    {
		switch (types[i])
		{
		  	case BibParserConstants.ADDRESS:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF ADDRESS");
					System.exit(-1);

				}
				break;
			case BibParserConstants.ANNOTE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF ANNOTE");
					System.exit(-1);

				}
				break;
			case BibParserConstants.AUTHOR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF AUTHOR");
					System.exit(-1);

				}
				break;
			case BibParserConstants.BOOKTITLE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF BOOKTITLE");
					System.exit(-1);

				}
				break;
			case BibParserConstants.CHAPTER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER))
				{
					System.out.println("ERROR: WRONG VALUE OF CHAPTER");
					System.exit(-1);

				}
				break;
			case BibParserConstants.CROSSREF:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.WORD))
				{
					System.out.println("ERROR: WRONG VALUE OF CROSSREF");
					System.exit(-1);

				}
				break;
			case BibParserConstants.EDITION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF EDITION");
					System.exit(-1);

				}
				break;
			case BibParserConstants.EDITOR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF EDITOR");
					System.exit(-1);

				}
				break;
			case BibParserConstants.HOWPUBLISHED:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF HOWPUBLISHED");
					System.exit(-1);

				}
				break;
			case BibParserConstants.INSTITUTION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF INSTITUTION");
					System.exit(-1);

				}
				break;
			case BibParserConstants.JOURNAL:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))
				{
					System.out.println("ERROR: WRONG VALUE OF JOURNAL");
					System.exit(-1);

				}
				break;
			case BibParserConstants.MONTH:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF MONTH");
					System.exit(-1);

				}
				break;
			case BibParserConstants.NOTE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF NOTE");
					System.exit(-1);

				}
				break;
			case BibParserConstants.NUMBER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER))
				{
					System.out.println("ERROR: WRONG VALUE OF NUMBER");
					System.exit(-1);

				}
				break;
			case BibParserConstants.ORGANIZATION:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF ORGANIZATION");
					System.exit(-1);

				}
				break;
			case BibParserConstants.PAGES:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))
				{
					System.out.println("ERROR: WRONG VALUE OF PAGES");
					System.exit(-1);

				}
				break;
			case BibParserConstants.PUBLISHER:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF PUBLISHER");
					System.exit(-1);

				}
				break;
			case BibParserConstants.SCHOOL:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF SCHOOL");
					System.exit(-1);

				}
				break;
			case BibParserConstants.SERIES:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF SERIES");
					System.exit(-1);

				}
				break;
			case BibParserConstants.REP_TYPE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF TYPE");
					System.exit(-1);

				}
				break;
			case BibParserConstants.YEAR:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.INTEGER) && !(st.type == BibParserConstants.YEAR_V) && !(st.type == BibParserConstants.PAGES_V))
				{
					System.out.println("ERROR: WRONG VALUE OF YEAR");
					System.exit(-1);

				}
				break;
			case BibParserConstants.VOLUME:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))
				{
					System.out.println("ERROR: WRONG VALUE OF VOLUME");
					System.exit(-1);

				}
				break;
			
			
			case BibParserConstants.KEY:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT))
				{
					System.out.println("ERROR: WRONG VALUE OF KEY");
					System.exit(-1);

				}
				break;
			case BibParserConstants.TITLE:
				st = (SymbolTable)symbtab.get(values[i].image);
				if(!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))
				{
					System.out.println("ERROR: WRONG VALUE OF TITLE");
					System.exit(-1);

				}
				break;
			default:
				System.out.println("ERROR: UNKNOWN OR INCORRECT FIELD FOUND IN");
				System.exit(-1);
				break;

		}

    }  }}


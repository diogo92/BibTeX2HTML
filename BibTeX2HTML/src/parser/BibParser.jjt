/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;  IGNORE_CASE = true;  UNICODE_INPUT = true;  FORCE_LA_CHECK = true;  lookahead = 10;}PARSER_BEGIN(BibParser)package parser;import java.util.Vector;import java.util.Scanner;import java.util.Collections;import java.util.Enumeration;import java.util.Hashtable;import java.util.Stack;import data.*;import reader.FileReader;import utils.*;
import htmlcreator.*;public class BibParser{  public static Hashtable symbtab = new Hashtable();  public static Vector < BibData > data;

  // Recyclable Structure to set in the intermediate memory
  public static BibData tmp_data;

  // Counter for current amount of types handled
  public static int count_data;

  public static boolean err_data;
    public static Vector < Vector < Object >> tree;  public static Vector < String > keys;

  public static Stack < Object > stack;  public static boolean firstStack = true;  public static int currIndex = 0;

  // Sets the correct type in the data vector
  public static void setTypeData(String type)  {
    if(type.equals("article"))    {
      data.add(new ArticleData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.journal, tmp_data.year, tmp_data.volume, tmp_data.number, tmp_data.pages, tmp_data.month, tmp_data.note, tmp_data.key));
      return;
    }
    if(type.equals("book"))
    {
      data.add(new BookData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.publisher, tmp_data.year, tmp_data.volume, tmp_data.number, tmp_data.edition, tmp_data.series, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("booklet"))
    {
      data.add(new BookletData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.howpublished, tmp_data.year, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key));
      return;
    }
    if(type.equals("conference"))
    {
      data.add(new ConferenceData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.number, tmp_data.series, tmp_data.pages, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("inbook"))    {
      data.add(new InbookData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.chapter, tmp_data.pages, tmp_data.publisher, tmp_data.year, tmp_data.volume, tmp_data.series, tmp_data.type, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("incollection"))
    {
      data.add(new IncollectionData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.publisher, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.series, tmp_data.type, tmp_data.chapter, tmp_data.pages, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("inproceedings"))    {
      data.add(new InproceedingsData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.booktitle, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.number, tmp_data.series, tmp_data.pages, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key));
      return;
    }
    if(type.equals("manual"))    {
      data.add(new ManualData(tmp_data.getCitationKey(), tmp_data.title, tmp_data.author, tmp_data.organization, tmp_data.address, tmp_data.edition, tmp_data.month, tmp_data.year, tmp_data.note, tmp_data.key));      return;
    }
    if(type.equals("mastersthesis"))
    {
      data.add(new MastersthesisData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.school, tmp_data.year, tmp_data.type, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("misc"))
    {
      data.add(new MiscData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.howpublished, tmp_data.month, tmp_data.year, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("phdthesis"))
    {
      data.add(new PhdthesisData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.school, tmp_data.year, tmp_data.type, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("proceedings"))
    {
      data.add(new ProceedingsData(tmp_data.getCitationKey(), tmp_data.title, tmp_data.year, tmp_data.editor, tmp_data.volume, tmp_data.series, tmp_data.address, tmp_data.month, tmp_data.organization, tmp_data.publisher, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("techreport"))
    {
      data.add(new TechreportData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.institution, tmp_data.year, tmp_data.type, tmp_data.number, tmp_data.address, tmp_data.month, tmp_data.note, tmp_data.key));
      return;    }
    if(type.equals("unpublished"))
    {
      data.add(new UnpublishedData(tmp_data.getCitationKey(), tmp_data.author, tmp_data.title, tmp_data.note, tmp_data.month, tmp_data.year, tmp_data.key));
      return;    }  }

  // Includes the values in the correct field in the temporary structure
  public static void setFieldData(String field, String value)  {
    if(field.equals("address"))
    {
      tmp_data.address = value;
      return;
    }
    if(field.equals("author"))
    {
      tmp_data.author = value;
      return;
    }
    if(field.equals("annote"))
    {
      tmp_data.annote = value;
      return;
    }
    if(field.equals("booktitle"))
    {
      tmp_data.booktitle = value;
      return;
    }
    if(field.equals("chapter"))
    {
      tmp_data.chapter = Integer.parseInt(value);
      return;
    }
    if(field.equals("crossref"))
    {
      tmp_data.crossref = value;
      return;
    }
    if(field.equals("edition"))
    {
      tmp_data.edition = value;
      return;
    }
    if(field.equals("editor"))
    {
      tmp_data.editor = value;
      return;
    }
    if(field.equals("howpublished"))
    {
      tmp_data.howpublished = value;
      return;
    }
    if(field.equals("institution"))
    {
      tmp_data.institution = value;
      return;
    }
    if(field.equals("journal"))
    {
      tmp_data.journal = value;
      return;
    }
    if(field.equals("key"))
    {
      tmp_data.key = value;
      return;
    }
    if(field.equals("month"))
    {
      tmp_data.month = value;
      return;
    }
    if(field.equals("note"))
    {
      tmp_data.note = value;
      return;
    }
    if(field.equals("number"))
    {
      tmp_data.number = Integer.parseInt(value);
      return;
    }
    if(field.equals("organization"))
    {
      tmp_data.organization = value;
      return;
    }
    if(field.equals("pages"))
    {
      tmp_data.pages = value;
      return;
    }
    if(field.equals("publisher"))
    {
      tmp_data.publisher = value;
      return;
    }
    if(field.equals("school"))
    {
      tmp_data.school = value;
      return;
    }
    if(field.equals("series"))
    {
      tmp_data.series = value;
      return;
    }
    if(field.equals("title"))
    {
      tmp_data.title = value;
      return;
    }
    if(field.equals("type"))
    {
      tmp_data.type = value;
      return;
    }
    if(field.equals("volume"))
    {
      tmp_data.volume = Integer.parseInt(value);
      return;
    }
    if(field.equals("year"))
    {
      tmp_data.year = value;
      return;
    }  }  public static void main(String args [])  {    start(args);  }  public static void start(String args [])  {    tree = new Vector < Vector < Object >> ();    stack = new Stack < Object > ();
    keys = new Vector < String > ();
    // Data control initialization
    count_data = 0;
    err_data = false;
    // ---    String temp;    SymbolTable temp2;    System.out.println("File to be parsed:");    System.out.print(">> ");    Scanner sc = new Scanner(System.in);    String file = sc.nextLine();    try    {      new BibParser(FileReader.getFile(file));      SimpleNode n = BibParser.Start();      n.dump(">>  ");      BibParser.CheckTree(n);      Enumeration t = symbtab.keys();      while (t.hasMoreElements() == true)      {        temp = (String) t.nextElement();        temp2 = (SymbolTable) symbtab.get(temp);        //  System.out.println(temp);
        /*   if(temp2.type != null)
        	System.out.println(" type = " + temp2.type);
        if(temp2.value != null)
        	System.out.println(" value = " + temp2.value);*/      }    }    catch (Exception e)    {      System.err.println("Error: " + e.getMessage());    }
    try    {
      HTMLWriter out = new HTMLWriter();
      out.readLists();
      out.createHTML();
    }
    catch (Exception e_html)
    {
      System.err.println("Error: " + e_html.getMessage());    }
    sc.close();  }}PARSER_END(BibParser)SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < ARROBA : "@" >| < BRACKET_START : "{" >| < BRACKET_END : "}" >| < COMMA : "," >| < EQUAL : "=" >| < DOUBLE_MARKS : "\"" >| < SINGLE_MARKS : "'" >| < STRING : "STRING" >| < ARTICLE : "ARTICLE" >| < BOOK : "BOOK" >| < BOOKLET : "BOOKLET" >| < CONFERENCE : "CONFERENCE" >| < INBOOK : "INBOOK" >| < INCOLLECTION : "INCOLLECTION" >| < INPROCEEDINGS : "INPROCEEDINGS" >| < MANUAL : "MANUAL" >| < MASTERSTHESIS : "MASTERSTHESIS" >| < MISC : "MISC" >| < PHDTHESIS : "PHDTHESIS" >| < PROCEEDINGS : "PROCEEDINGS" >| < TECHREPORT : "TECHREPORT" >| < UNPUBLISHED : "UNPUBLISHED" >| < AUTHOR : "AUTHOR" >| < ANNOTE : "ANNOTE" >| < BOOKTITLE : "BOOKTITLE" >| < CHAPTER : "CHAPTER" >| < CROSSREF : "CROSSREF" >| < EDITOR : "EDITOR" >| < INSTITUTION : "INSTITUTION" >| < ORGANIZATION : "ORGANIZATION" >| < SCHOOL : "SCHOOL" >| < JOURNAL : "JOURNAL" >| < TITLE : "TITLE" >| < YEAR : "YEAR" >| < VOLUME : "VOLUME" >| < NUMBER : "NUMBER" >| < ADDRESS : "ADDRESS" >| < HOWPUBLISHED : "HOWPUBLISHED" >| < PUBLISHER : "PUBLISHER" >| < SERIES : "SERIES" >| < EDITION : "EDITION" >| < PAGES : "PAGES" >| < PAGES_V :    < DOUBLE_MARKS > < INTEGER >    (      "-"    | "--"    )    < INTEGER > < DOUBLE_MARKS >  | < SINGLE_MARKS > < INTEGER >    (      "-"    | "--"    )    < INTEGER > < SINGLE_MARKS >>| < MONTH : "MONTH" >| < NOTE : "NOTE" >| < YEAR_V :    (      "\"" < INTEGER > ("?")? "\""    )  |    (      "'" < INTEGER > ("?")? "'"    ) >| < KEY : "KEY" >| < REP_TYPE : "REP_TYPE" >| < INTEGER : < DIGIT > (< DIGIT >)* >| < #DIGIT : [ "0"-"9" ] >| < QUOTED_TEXT :    < DOUBLE_MARKS >    (      < INTEGER >    | < LETTER >    | < SPECIAL >    | "\\"      (        < SINGLE_MARKS >      | < DOUBLE_MARKS >      )    | < SINGLE_MARKS >    )*    < DOUBLE_MARKS >  | < SINGLE_MARKS >    (      < INTEGER >    | < LETTER >    | < SPECIAL >    | "\\"      (        < SINGLE_MARKS >      | < DOUBLE_MARKS >      )    | < DOUBLE_MARKS >    )*    < SINGLE_MARKS >>| < WORD :    < LETTER >    (      < LETTER >    | < INTEGER >    )* >| < TEXT :    (      < LETTER >    | < INTEGER >    )+ >| < #SPECIAL : [ "\r", "\n", " "-"!", "#"-"&", "("-"/", ":"-"@", "["-"`", " "-"!", "{"-"~" ] >| < #LETTER : [ "A"-"z" ] >}void error_skipto(int kind) #void :{}{  {    ParseException e = generateParseException(); // generate the exception object.
    System.err.println(e.toString()); // print the error message
    Token t;    do    {      t = getNextToken();    }    while (t.kind != kind);  }}SimpleNode Start() :{}{  try  {    (Statement()) *    {      return jjtThis;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Statement() :{
  // Insert previous read into intermediate structure only if it has no errors (in-case parser/syntax/semantic error skips)
  if(count_data != 0 && err_data)  {
    setTypeData(tmp_data.getDataType());  }
  err_data = false;
  tmp_data = new BibData();
  count_data++;
  System.err.println(count_data);
  String type;
}{  try  {    Arroba() type = Type()
    {
      // Set the type intermediate structure
      tmp_data.setDataType(type);
      System.err.println(type);
    }
  	< BRACKET_START > Data() < BRACKET_END >
  }   catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Arroba() :{}{  try  {    < ARROBA >  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Data() :{}{  try  {    Key() (Attribute() (Attribute()) *) ?  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Key() :{  Token key = null;}{  try  {    key = < WORD >    {      if (key == null)      {
        err_data = true;        System.err.println("Empty key");        throw new ParseException("Key is required");      }      else      {        jjtThis.jjtSetValue(key);        symbtab.put(key.image, new SymbolTable(key.kind, key.image));
        // Place in intermediate structure
        tmp_data.citationKey = key.image;      }    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Equal() :{}{  try  {    < EQUAL >  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Type() :{  Token value;}{  try  {    ((value = < WORD >)  | (value = < TEXT >)  | (value = < CONFERENCE >)  | (value = < ARTICLE >)  | (value = < BOOK >)  | (value = < BOOKLET >)  | (value = < INBOOK >)  | (value = < INCOLLECTION >)  | (value = < INPROCEEDINGS >)  | (value = < MANUAL >)  | (value = < MASTERSTHESIS >)  | (value = < MISC >)  | (value = < PHDTHESIS >)  | (value = < PROCEEDINGS >)  | (value = < TECHREPORT >)  | (value = < UNPUBLISHED >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Field() :{  Token value;}{  try  {    ((value = < AUTHOR >)  | (value = < ANNOTE >)  | (value = < BOOKTITLE >)  | (value = < CHAPTER >)  | (value = < CROSSREF >)  | (value = < EDITOR >)  | (value = < INSTITUTION >)  | (value = < ORGANIZATION >)  | (value = < SCHOOL >)  | (value = < JOURNAL >)  | (value = < TITLE >)  | (value = < YEAR >)  | (value = < VOLUME >)  | (value = < NUMBER >)  | (value = < ADDRESS >)  | (value = < HOWPUBLISHED >)  | (value = < PUBLISHER >)  | (value = < SERIES >)  | (value = < EDITION >)  | (value = < NOTE >)  | (value = < MONTH >)  | (value = < PAGES >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}String Value() :{  Token value;}{  try  {    ((value = < WORD >)  | (value = < QUOTED_TEXT >)  | (value = < INTEGER >)  | (value = < PAGES_V >)  | (value = < YEAR_V >))    {      jjtThis.jjtSetValue(value);      symbtab.put(value.image, new SymbolTable(value.kind, value.image));
      return value.image;    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void Attribute() :{
  String field;
  String value;
}{  try  {    (< COMMA > field = Field() Equal() value = Value())
    {
      //setFieldData(field, value);    }  }  catch (ParseException e)  {
    err_data = true;    error_skipto(BibParserConstants.BRACKET_END);  }}void CheckTree(SimpleNode n) #void :{}{  {    if (n.id == BibParserTreeConstants.JJTSTATEMENT) checkStatement(n);    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn != null)        {          CheckTree(auxn);        }      }    }  }}void checkAttribute(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTFIELD || auxn.id == BibParserTreeConstants.JJTVALUE)        {          stack.push(auxn.jjtGetValue());        }      }    }  }}void checkData(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTKEY)        {          stack.push(auxn.jjtGetValue());        }        if (auxn.id == BibParserTreeConstants.JJTATTRIBUTE)        {          checkAttribute(auxn);        }      }      analyzeStack();    }  }}void checkType(SimpleNode n) #void :{}{  {    if (!(((Token) n.jjtGetValue()).kind == BibParserConstants.ARTICLE || ((Token) n.jjtGetValue()).kind == BibParserConstants.BOOK || ((Token) n.jjtGetValue()).kind == BibParserConstants.BOOKLET || ((Token) n.jjtGetValue()).kind == BibParserConstants.CONFERENCE || ((Token) n.jjtGetValue()).kind == BibParserConstants.INBOOK || ((Token) n.jjtGetValue()).kind == BibParserConstants.INCOLLECTION || ((Token) n.jjtGetValue()).kind == BibParserConstants.INPROCEEDINGS || ((Token) n.jjtGetValue()).kind == BibParserConstants.MANUAL || ((Token) n.jjtGetValue()).kind == BibParserConstants.MASTERSTHESIS || ((Token) n.jjtGetValue()).kind == BibParserConstants.MISC || ((Token) n.jjtGetValue()).kind == BibParserConstants.PHDTHESIS || ((Token) n.jjtGetValue()).kind == BibParserConstants.PROCEEDINGS || ((Token) n.jjtGetValue()).kind == BibParserConstants.TECHREPORT || ((Token) n.jjtGetValue()).kind == BibParserConstants.UNPUBLISHED))    {      System.err.println("No such type");    }    else    {      stack.push((Token) n.jjtGetValue());    }  }}void checkStatement(SimpleNode n) #void :{}{  {    if (n.jjtGetNumChildren() > 0)    {      for (int i = 0; i < n.jjtGetNumChildren(); ++i)      {        SimpleNode auxn = (SimpleNode) n.jjtGetChild(i);        if (auxn.id == BibParserTreeConstants.JJTTYPE)        {          checkType(auxn);        }        if (auxn.id == BibParserTreeConstants.JJTDATA)        {          checkData(auxn);        }      }    }  }}void analyzeStack() #void :{}{  {    Vector < Object > stackelems = new Vector < Object > ();    while (!stack.empty())    {      stackelems.addElement(stack.peek());      stack.pop();    }    Collections.reverse(stackelems);    switch (((Token) stackelems.elementAt(0)).kind)    {      case BibParserConstants.ARTICLE : case BibParserConstants.BOOK : case BibParserConstants.BOOKLET : case BibParserConstants.CONFERENCE : case BibParserConstants.INBOOK : case BibParserConstants.INCOLLECTION : case BibParserConstants.INPROCEEDINGS : case BibParserConstants.MANUAL : case BibParserConstants.MASTERSTHESIS : case BibParserConstants.MISC : case BibParserConstants.PHDTHESIS : case BibParserConstants.PROCEEDINGS : case BibParserConstants.TECHREPORT : case BibParserConstants.UNPUBLISHED : analyzeType(stackelems, ((Token) stackelems.elementAt(0)).kind);      break;    }  }}void analyzeType(Vector < Object > elems, int type) #void :{}{  {    int currPairInd = 0;    int numPair = (elems.size() - 1) / 2;    Token key = (Token) elems.elementAt(1);
    keys.add(key.image);    elems.remove(1);    int [ ] types = new int [ numPair ];    Token [ ] values = new Token [ numPair ];    for (int i = 0; i < numPair; i++)    {      values [ i ] = new Token();    }    for (int i = 1; i < elems.size(); i += 2)    {      types [ currPairInd ] = ((Token) elems.elementAt(i)).kind;      values [ currPairInd ] = (Token) elems.elementAt(i + 1);      currPairInd++;    }    try    {
    for ( int i = 0 ; i<keys.size()-1;i++)
    {
		if(keys.elementAt(i).equals(key.image))
			throw new SemanticException("ERROR: repeated key found " + key.image);
				
    }      for (int i = 0; i < numPair; i++)      {        for (int j = i + 1; j < numPair; j++)        {          if (types [ i ] == types[ j ])          {            throw new SemanticException("ERROR: repeated field found in entry " + key.image);          }        }      }    }    catch (SemanticException e)    {
      err_data = true;      System.err.println(e.getMessage());    }    try    {      switch (type)      {        case BibParserConstants.ARTICLE : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.JOURNAL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in ARTICLE " + key.image);        }        break;        case BibParserConstants.BOOK : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in BOOK " + key.image);        }        break;        case BibParserConstants.BOOKLET : if (!Utilities.contains(types, BibParserConstants.TITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in BOOKLET " + key.image);        }        break;        case BibParserConstants.CONFERENCE : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.BOOKTITLE) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in CONFERENCE " + key.image);        }        break;        case BibParserConstants.INBOOK : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.CHAPTER))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INBOOK " + key.image);        }        break;        case BibParserConstants.INCOLLECTION : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.PUBLISHER) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.BOOKTITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INCOLLECTION " + key.image);        }        break;        case BibParserConstants.INPROCEEDINGS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.BOOKTITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in INPROCEEDINGS " + key.image);        }        break;        case BibParserConstants.MANUAL : if (!Utilities.contains(types, BibParserConstants.TITLE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MANUAL " + key.image);        }        break;        case BibParserConstants.MASTERSTHESIS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.SCHOOL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MASTERSTHESIS " + key.image);        }        break;        case BibParserConstants.MISC : /* NOT NEEDED */ /*if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.HOWPUBLISHED) || !Utilities.contains(types, BibParserConstants.YEAR) || !Utilities.contains(types, BibParserConstants.MONTH) || !Utilities.contains(types, BibParserConstants.NOTE) || !Utilities.contains(types, BibParserConstants.KEY))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in MISC " + key.image);        }*/        break;        case BibParserConstants.PHDTHESIS : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.SCHOOL) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in PHDTHESIS " + key.image);        }        break;        case BibParserConstants.PROCEEDINGS : if (!Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in PROCEDINGS " + key.image);        }        break;        case BibParserConstants.TECHREPORT : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.INSTITUTION) || !Utilities.contains(types, BibParserConstants.YEAR))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in TECHREPORT " + key.image);        }        break;        case BibParserConstants.UNPUBLISHED : if (!Utilities.contains(types, BibParserConstants.AUTHOR) || !Utilities.contains(types, BibParserConstants.TITLE) || !Utilities.contains(types, BibParserConstants.NOTE))        {
          err_data = true;          throw new SemanticException("ERROR: required field not present in UNPUBLISHED " + key.image);        }        break;        default : break;      }    }    catch (SemanticException e)    {
      err_data = true;      System.err.println(e.getMessage());    }    checkValueTypes(types, values, numPair, key);  }}void checkValueTypes(int [ ] types, Token [ ] values, int numPair, Token key) #void :{}{  {    SymbolTable st;    for (int i = 0; i < numPair; i++)    {      try      {        switch (types [ i ])        {          case BibParserConstants.ADDRESS : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ADDRESS at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.ANNOTE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ANNOTE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.AUTHOR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of AUTHOR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.BOOKTITLE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of BOOKTITLE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.CHAPTER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of CHAPTER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.CROSSREF : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.WORD))          {
            err_data = true;            throw new SemanticException("Wrong value of CROSSREF at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.EDITION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of EDITION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.EDITOR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of EDITOR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.HOWPUBLISHED : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of HOWPUBLISHED at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.INSTITUTION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of INSTITUTION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.JOURNAL : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))          {
            err_data = true;            throw new SemanticException("Wrong value of JOURNAL at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.MONTH : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of MONTH at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.NOTE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of NOTE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.NUMBER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of NUMBER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.ORGANIZATION : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of ORGANIZATION at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.PAGES : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of PAGES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          else if (!PagesControl.verifyPages(values [ i ].image))          {
            err_data = true;            throw new SemanticException("Wrong value of PAGES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.PUBLISHER : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of PUBLISHER at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.SCHOOL : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of SCHOOL at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.SERIES : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of SERIES at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.REP_TYPE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of TYPE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.YEAR : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.INTEGER) && !(st.type == BibParserConstants.YEAR_V) && !(st.type == BibParserConstants.PAGES_V))          {
            err_data = true;            throw new SemanticException("Wrong value of YEAR at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.VOLUME : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.PAGES_V) && !(st.type == BibParserConstants.INTEGER))          {
            err_data = true;            throw new SemanticException("Wrong value of VOLUME at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.KEY : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT))          {
            err_data = true;            throw new SemanticException("Wrong value of KEY at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          case BibParserConstants.TITLE : st = (SymbolTable) symbtab.get(values [ i ].image);          if (!(st.type == BibParserConstants.QUOTED_TEXT) && !(st.type == BibParserConstants.WORD))          {
            err_data = true;            throw new SemanticException("Wrong value of TITLE at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " in entry " + key.image);          }          break;          default :
          {
            err_data = true;            throw new SemanticException("unknown or incorrect field found at line " + values [ i ].beginLine + " column " + values [ i ].beginColumn + " : " + values [ i ].image + "in entry " + key.image);          }
          break;        }      }      catch (SemanticException e)      {
        err_data = true;        System.err.println("Semantic error: " + e.getMessage());      }    }  }}
